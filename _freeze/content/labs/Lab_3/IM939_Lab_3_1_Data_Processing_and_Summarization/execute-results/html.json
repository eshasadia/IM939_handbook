{
  "hash": "9575a0be985e8465694fd7605bf47595",
  "result": {
    "markdown": "# Lab: Data Processing and Summarization\n\nHere we will be exploring different functions in data processing and summarization.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# Importing libraries\nimport numpy as np\nimport pandas as pd\nimport statsmodels.api as sm\nfrom scipy.spatial.distance import cdist # This is the function that computes the Mahalanobis distance\nfrom scipy.stats import skew, kurtosis # The skew and kurtosis of a distribution\nfrom statsmodels.robust.scale import mad # This computes the median absolute deviation of a distribution\nimport matplotlib.pyplot as plt\n#%matplotlib inline # Display matplotlib plots inline with the text. +info: https://stackoverflow.com/a/43028034/1913457\n```\n:::\n\n\n## Outliers\n\nIn this section we will be applying several methods to identify outliers. We will be using a custom dataset called `accord_sedan.csv` that contains cars properties. The dataset is provided as a csv file.\n\n### Assess data\n\nAs usual, we will want to start loading the data and assessing it:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# Loading Data\ndf = pd.read_csv('data/raw/accord_sedan.csv')\n\n# Inspecting the few first rows of the dataframe\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>price</th>\n      <th>mileage</th>\n      <th>year</th>\n      <th>trim</th>\n      <th>engine</th>\n      <th>transmission</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>14995</td>\n      <td>67697</td>\n      <td>2006</td>\n      <td>ex</td>\n      <td>4 Cyl</td>\n      <td>Manual</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>11988</td>\n      <td>73738</td>\n      <td>2006</td>\n      <td>ex</td>\n      <td>4 Cyl</td>\n      <td>Manual</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>11999</td>\n      <td>80313</td>\n      <td>2006</td>\n      <td>lx</td>\n      <td>4 Cyl</td>\n      <td>Automatic</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>12995</td>\n      <td>86096</td>\n      <td>2006</td>\n      <td>lx</td>\n      <td>4 Cyl</td>\n      <td>Automatic</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>11333</td>\n      <td>79607</td>\n      <td>2006</td>\n      <td>lx</td>\n      <td>4 Cyl</td>\n      <td>Automatic</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAnd we can get some summary statistics, too:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndf.describe()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>price</th>\n      <th>mileage</th>\n      <th>year</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>count</th>\n      <td>417.000000</td>\n      <td>417.000000</td>\n      <td>417.0</td>\n    </tr>\n    <tr>\n      <th>mean</th>\n      <td>12084.242206</td>\n      <td>89725.779376</td>\n      <td>2006.0</td>\n    </tr>\n    <tr>\n      <th>std</th>\n      <td>2061.430034</td>\n      <td>25957.872271</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>min</th>\n      <td>6900.000000</td>\n      <td>19160.000000</td>\n      <td>2006.0</td>\n    </tr>\n    <tr>\n      <th>25%</th>\n      <td>10779.000000</td>\n      <td>71844.000000</td>\n      <td>2006.0</td>\n    </tr>\n    <tr>\n      <th>50%</th>\n      <td>11995.000000</td>\n      <td>89900.000000</td>\n      <td>2006.0</td>\n    </tr>\n    <tr>\n      <th>75%</th>\n      <td>13000.000000</td>\n      <td>106705.000000</td>\n      <td>2006.0</td>\n    </tr>\n    <tr>\n      <th>max</th>\n      <td>18995.000000</td>\n      <td>149269.000000</td>\n      <td>2006.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nBut this might be difficult to spot outliers. This is where We can use data visualisations to identify outliers visually. \n\n\n### Identify outliers visually\n\nIn this case we will **explore variables individually (1D)** by creating a _boxplot_[^boxplot]. We will visualise the columns `price` and `mileage` using matplotlib's subplots, which combines multiple plots into a single figure:\n\n[^boxplot]: Boxplots may be difficult to interpret if we are not used to them. From [Wikipedia](https://en.wikipedia.org/wiki/Box_plot): \"In descriptive statistics, a box plot or boxplot is a method for graphically demonstrating the locality, spread and skewness groups of numerical data through their quartiles.\" ![](figs/440px-Boxplot_vs_PDF.svg.png)\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# 1D Visualizations\nplt.figure(figsize=(9, 5)) # Setting the figure's size: format width, height (in inches)\nplt.subplot(1,2,1) # subplot(nrows, ncols, index, **kwargs)\nplt.boxplot(df.price)\nplt.title(\"Boxplot of the Price attribute\")\nplt.subplot(1,2,2)\nplt.boxplot(df.mileage)\nplt.title(\"Boxplot of the Mileage attribute\");\n# A semicolon in Python denotes separation, rather than termination. \n# It allows you to write multiple statements on the same line. \n\n```\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_3_1_Data_Processing_and_Summarization_files/figure-html/cell-5-output-1.png){width=741 height=431}\n:::\n:::\n\n\nBut we may want to **identify the 2D outliers** using a scatterplot\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# 2D Visualization\nplt.scatter(df.price, df.mileage, alpha = .5)\nplt.xlabel('Price')\nplt.ylabel('Mileage')\nplt.title('Mileage vs. Price\\n');\n```\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_3_1_Data_Processing_and_Summarization_files/figure-html/cell-6-output-1.png){width=619 height=467}\n:::\n:::\n\n\n::: callout-note\nVisually, outliers appear to be outside the 'normal' range of the rest of the points. A few outliers are quite obvious to spot, but the choice of the threshold (the limit after which you decide to label a point as an outlier) visually remains a very subjective matter.\n:::\n\n## Computing outliers' threshold\n\nAdd two new columns to the dataframe called `isOutlierPrice` and `isOutlierMileage`. We will define our threshold as **2 times standard deviations away from the mean** for `price`  and `mileage`, respectively.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Computing the isOutlierPrice column\nupper_threshold_price = df.price.mean() + 2*df.price.std() \nlower_threshold_price = df.price.mean() - 2*df.price.std()\ndf['isOutlierPrice'] = ((df.price > upper_threshold_price) | (df.price < lower_threshold_price))\n\n# Computing the isOutlierMileage column\nupper_threshold_mileage = df.mileage.mean() + 2*df.mileage.std()\nlower_threshold_mileage = df.mileage.mean() - 2*df.mileage.std()\ndf['isOutlierMileage'] = ((df.mileage > upper_threshold_mileage) | (df.mileage < lower_threshold_mileage))\n\n# Inspect the new DataFrame with the added columns\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>price</th>\n      <th>mileage</th>\n      <th>year</th>\n      <th>trim</th>\n      <th>engine</th>\n      <th>transmission</th>\n      <th>isOutlierPrice</th>\n      <th>isOutlierMileage</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>14995</td>\n      <td>67697</td>\n      <td>2006</td>\n      <td>ex</td>\n      <td>4 Cyl</td>\n      <td>Manual</td>\n      <td>False</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>11988</td>\n      <td>73738</td>\n      <td>2006</td>\n      <td>ex</td>\n      <td>4 Cyl</td>\n      <td>Manual</td>\n      <td>False</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>11999</td>\n      <td>80313</td>\n      <td>2006</td>\n      <td>lx</td>\n      <td>4 Cyl</td>\n      <td>Automatic</td>\n      <td>False</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>12995</td>\n      <td>86096</td>\n      <td>2006</td>\n      <td>lx</td>\n      <td>4 Cyl</td>\n      <td>Automatic</td>\n      <td>False</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>11333</td>\n      <td>79607</td>\n      <td>2006</td>\n      <td>lx</td>\n      <td>4 Cyl</td>\n      <td>Automatic</td>\n      <td>False</td>\n      <td>False</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: callout-tip\n\n### Alternative method\n\nWe may want to use this more succint approach:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Second way of doing the above using the np.where() function\ndf['isOutlierPrice'] = np.where(abs(df.price - df.price.mean()) < 2*df.price.std(), False, True)\ndf['isOutlierMileage'] = np.where(abs(df.mileage - df.mileage.mean()) < 2*df.mileage.std(), False, True)\n\n# Inspect the new DataFrame with the added columns\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>price</th>\n      <th>mileage</th>\n      <th>year</th>\n      <th>trim</th>\n      <th>engine</th>\n      <th>transmission</th>\n      <th>isOutlierPrice</th>\n      <th>isOutlierMileage</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>14995</td>\n      <td>67697</td>\n      <td>2006</td>\n      <td>ex</td>\n      <td>4 Cyl</td>\n      <td>Manual</td>\n      <td>False</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>11988</td>\n      <td>73738</td>\n      <td>2006</td>\n      <td>ex</td>\n      <td>4 Cyl</td>\n      <td>Manual</td>\n      <td>False</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>11999</td>\n      <td>80313</td>\n      <td>2006</td>\n      <td>lx</td>\n      <td>4 Cyl</td>\n      <td>Automatic</td>\n      <td>False</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>12995</td>\n      <td>86096</td>\n      <td>2006</td>\n      <td>lx</td>\n      <td>4 Cyl</td>\n      <td>Automatic</td>\n      <td>False</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>11333</td>\n      <td>79607</td>\n      <td>2006</td>\n      <td>lx</td>\n      <td>4 Cyl</td>\n      <td>Automatic</td>\n      <td>False</td>\n      <td>False</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAs we'd expect, both methods produce the same output.\n\n:::\n\nNow that we have these two new columns, we could visualize these values with a different color in the plot. Observe whether they are the same as you would mark them:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Visualizing outliers in a different color\ncol = ['tomato' if i+j else 'seagreen' for i,j in zip(df.isOutlierPrice, df.isOutlierMileage)]\nplt.scatter(df.price, df.mileage, color = col)\nplt.xlabel('Price')\nplt.ylabel('Mileage')\nplt.title('Mileage vs. Price : Outliers 2+ std\\'s away from the mean\\n');\n```\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_3_1_Data_Processing_and_Summarization_files/figure-html/cell-9-output-1.png){width=619 height=467}\n:::\n:::\n\n\nVisually filtering out outliers can be an effective tactic if we're just trying to conduct a quick and dirty experimentation. However, when we need to perform a solid and founded analysis, it's better to have a robust justification for our choices.  \n\nIn this case, we can use the deviation from the mean to define a threshold that separates 'normal' values from 'outliers'. Here, we opted for a two standard deviation threshold. \n\nThe mathematical intuition behind this, is that under the normality assumption (if we assume our variable is normally distributed, which it almost is, refer to the next plot), then the probability of it having a value two standard deviations OR MORE away from the mean, is around 5%, which is very unlikely to happen. This is why we label these data points as outliers with respect to the (assumed) probability distribution of the variable. But this remains a way to identify 1D outliers only (identifying outliers within each column separately)\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Histograms of Price and Mileage (checking the normality assumption)\nplt.subplot(1,2,1)\nplt.hist(df.price, bins = 12)\nplt.title('Price')\nplt.subplot(1,2,2)\nplt.hist(df.mileage, bins = 15)\nplt.title('Mileage');\n```\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_3_1_Data_Processing_and_Summarization_files/figure-html/cell-10-output-1.png){width=582 height=431}\n:::\n:::\n\n\n### Mahalanobis distance\n\n1) Using the 2D Mahalanobis distance to find outliers\n\n::: {.cell .column-page-inset-right execution_count=10}\n``` {.python .cell-code}\n# Mean vector (computing the mean returns a Series, which we need to convert back to a DataFrame because cdist requires it)\nmean_v = df.iloc[:, 0:2].mean().to_frame().T # DataFrame.T returns the Transpose of the DataFrame\n#mean_v = np.asarray([df.price.mean(), df.mileage.mean() ]).reshape(1,2) # This is a better way of writing the line before (for our use case : cdist function)\n\n# Computing the Mahalanobis distance of each row to the mean vector\nd = cdist(df.iloc[:, 0:2], mean_v, metric='mahalanobis')\n#d = cdist(df[['price', 'mileage']].values, mean_v, metric='mahalanobis') # Another way of writing the line before\n\n# Visualizing the scatter plot while coloring each point (i.e row) with a color from a chosen gradient colormap corresponding to the mahalanobis score\nplt.figure(figsize=(12, 5))\nplt.scatter(df.price, df.mileage, c = d.flatten(), cmap = 'plasma') # in order to know why we use flatten() on d, try printing d with and without flatten\nplt.colorbar() # to show the colorbar\nplt.xlabel('Price')\nplt.ylabel('Mileage')\nplt.title('Mileage vs. Price colored by a 2D Mahalanobis score\\n');\n```\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_3_1_Data_Processing_and_Summarization_files/figure-html/cell-11-output-1.png){width=893 height=467}\n:::\n:::\n\n\n## Q-Q Plots\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Getting the Data in\ndf_tuber = pd.read_csv('data/raw/TB_burden_countries_2014-09-29.csv')\n\n# Filling missing numeric values (I repeat NUMERIC COLUMNS, I didn't touch categorical ones because we don't need them here)\ndf_tuber = df_tuber.fillna(value=df_tuber.mean(numeric_only = True))\n\n# Inspecting missing values in dataset\npd.isnull(df_tuber).sum()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\ncountry                      0\niso2                        23\niso3                         0\niso_numeric                  0\ng_whoregion                  0\nyear                         0\ne_pop_num                    0\ne_prev_100k                  0\ne_prev_100k_lo               0\ne_prev_100k_hi               0\ne_prev_num                   0\ne_prev_num_lo                0\ne_prev_num_hi                0\ne_mort_exc_tbhiv_100k        0\ne_mort_exc_tbhiv_100k_lo     0\ne_mort_exc_tbhiv_100k_hi     0\ne_mort_exc_tbhiv_num         0\ne_mort_exc_tbhiv_num_lo      0\ne_mort_exc_tbhiv_num_hi      0\nsource_mort                  1\ne_inc_100k                   0\ne_inc_100k_lo                0\ne_inc_100k_hi                0\ne_inc_num                    0\ne_inc_num_lo                 0\ne_inc_num_hi                 0\ne_tbhiv_prct                 0\ne_tbhiv_prct_lo              0\ne_tbhiv_prct_hi              0\ne_inc_tbhiv_100k             0\ne_inc_tbhiv_100k_lo          0\ne_inc_tbhiv_100k_hi          0\ne_inc_tbhiv_num              0\ne_inc_tbhiv_num_lo           0\ne_inc_tbhiv_num_hi           0\nsource_tbhiv                 1\nc_cdr                        0\nc_cdr_lo                     0\nc_cdr_hi                     0\ndtype: int64\n```\n:::\n:::\n\n\n1) Pick one of the columns from the Tuberculosis data and copy it into a numpy array as before\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Picking a column (I created a variable for this so I (and you (: ) can modify the column easily here and the change will be carried out everywhere I use the variable colname)\ncolname = 'e_prev_100k'\n\n# Creating a numpy array from our column\ncol = np.array(df_tuber[colname])\n\n# Printing the type of our newly created column\nprint(type(col))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'numpy.ndarray'>\n```\n:::\n:::\n\n\n1) Compare this selected column to a Normal distribution. Then Sample from a Normal distribution and show a second Q-Q plot\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# Plotting the Q-Q Plot for our column\nsm.qqplot(col, line='r')\nplt.title('Q-Q Plot of the \"{}\" column of our dataset'.format(colname));\n\n# Plotting the Q-Q Plot for the log of our column\nsm.qqplot(np.log(col), line='r')\nplt.title('Q-Q Plot of the Log of the \"{}\" column'.format(colname));\n\n# Sampling from a Gaussian and a uniform distribution\nsample_norm = np.random.randn(1000)\nsample_unif = np.random.rand(1000)\n\n# Plotting the second Q-Q Plot for our sample (that was generated using a normal distribution)\nsm.qqplot(sample_norm, line='r')\nplt.title('Q-Q Plot of the generated sample (Gaussian)')\nsm.qqplot(sample_unif, line='r')\nplt.title('Q-Q Plot of the generated sample (Uniform)');\n```\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_3_1_Data_Processing_and_Summarization_files/figure-html/cell-14-output-1.png){width=604 height=449}\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_3_1_Data_Processing_and_Summarization_files/figure-html/cell-14-output-2.png){width=585 height=449}\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_3_1_Data_Processing_and_Summarization_files/figure-html/cell-14-output-3.png){width=587 height=449}\n:::\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_3_1_Data_Processing_and_Summarization_files/figure-html/cell-14-output-4.png){width=609 height=449}\n:::\n:::\n\n\n<p>\n    Go ahead and change the colname variable (question 1) into a different column name (that you can pick from the list you have just before question 1 (but do pick a numeric column). And re-execute the code from question 1 and question 2 and you'll see your new Q-Q plot of the column you just picked.\n</p>\n\n1) Have a look at the slides from Week 03 for different shapes\n\n<p>\n    Ok ? Now try to guess the shape of the distribution of our selected column (shape of its histogram) from its Q-Q Plot above.\n</p>\n\n1) Visualise the column on a histogram and reflect on whether the shape you inferred from Q-Q plots and the shape of the histogram correlate\n\n::: {.cell .column-page-inset-right execution_count=14}\n``` {.python .cell-code}\n# Histogramming the column we picked (not sure the verb exists though)\nplt.figure(figsize=(12, 5))\nplt.subplot(1,2,1)\nplt.title('Histogram of \"{}\"'.format(colname))\nplt.hist(col)\nplt.subplot(1,2,2)\nplt.title('Histogram of Log \"{}\"'.format(colname))\nplt.hist(np.log(col));\n```\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_3_1_Data_Processing_and_Summarization_files/figure-html/cell-15-output-1.png){width=955 height=431}\n:::\n:::\n\n\n<p>\n    Of course it does ! From the shape of the Q-Q Plot above (convex, slope upwards) and the Slide of Q-Q Plots from Week 3, we could conclude before looking at the histogram that our distribution was right tailed (or positively skewed if you're into complex vocabulary lol). And it is !\n</p>\n\n## Distributions, Sampling\n\n1) Inspecting the effect of sample size on descriptive statistics\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# Defining a few variables se we can change their values easiliy without having to change the rest of the code\nn = [5, 20, 100, 2000]\nstds = [0.5, 1, 3]\n\n# Initializing empty 2D arrays where we're going to store the results of our simulation\nmean = np.empty([len(n), len(stds)])\nstd = np.empty([len(n), len(stds)])\nskewness = np.empty([len(n), len(stds)])\nkurtos = np.empty([len(n), len(stds)])\n\n# Conducting the experiments and storing the results in the respective 2D arrays\nfor i, sample_size in enumerate(n):\n    for j, theoritical_std in enumerate(stds):\n        sample = np.random.normal(loc=0, scale=theoritical_std, size=sample_size)\n        mean[i,j] = sample.mean()\n        std[i,j] = sample.std()\n        skewness[i,j] = skew(sample)\n        kurtos[i,j] = kurtosis(sample)\n\n# Turning the mean 2D array into a pandas dataframe\nmean = pd.DataFrame(mean, columns = stds, index = n)\nmean = mean.rename_axis('Sample Size').rename_axis(\"Standard Deviation\", axis=\"columns\")\n\n# Turning the std 2D array into a pandas dataframe\nstd = pd.DataFrame(std, columns = stds, index = n)\nstd = std.rename_axis('Sample Size').rename_axis(\"Standard Deviation\", axis=\"columns\")\n\n# Turning the skewness 2D array into a pandas dataframe\nskewness = pd.DataFrame(skewness, columns = stds, index = n)\nskewness = skewness.rename_axis('Sample Size').rename_axis(\"Standard Deviation\", axis=\"columns\")\n\n# Turning the kurtosis 2D array into a pandas dataframe\nkurtos = pd.DataFrame(kurtos, columns = stds, index = n)\nkurtos = kurtos.rename_axis('Sample Size').rename_axis(\"Standard Deviation\", axis=\"columns\")\n\nprint(\"GAUSSIAN DISTRIBUTION\\n\")\nprint('Results for the Mean :')\nmean # This is a dataframe containing the means of the samples generated with different values of std and sample size\nprint('Results for the Standard Deviation :')\nstd # This is a dataframe containing the standard deviations of the samples generated with different values of std and sample size\nprint('Results for the Skewness :')\nskewness # This is a dataframe containing the skews of the samples generated with different values of std and sample size\nprint('Results for the Kurtosis :')\nkurtos # This is a dataframe containing the kurtosis of the samples generated with different values of std and sample size\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGAUSSIAN DISTRIBUTION\n\nResults for the Mean :\nResults for the Standard Deviation :\nResults for the Skewness :\nResults for the Kurtosis :\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Standard Deviation</th>\n      <th>0.5</th>\n      <th>1.0</th>\n      <th>3.0</th>\n    </tr>\n    <tr>\n      <th>Sample Size</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>5</th>\n      <td>-0.559811</td>\n      <td>0.039484</td>\n      <td>-1.150575</td>\n    </tr>\n    <tr>\n      <th>20</th>\n      <td>0.066515</td>\n      <td>-1.021888</td>\n      <td>-0.178457</td>\n    </tr>\n    <tr>\n      <th>100</th>\n      <td>-0.238192</td>\n      <td>-0.852055</td>\n      <td>-0.012660</td>\n    </tr>\n    <tr>\n      <th>2000</th>\n      <td>0.126590</td>\n      <td>0.011198</td>\n      <td>-0.044190</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<p>\n    Basically, the more data you have (the bigger your sample), the more accurate your empirical estimates are going to be. Observe for example the values of mean (1st DataFrame) and variance (2nd DataFrame) for the 2000 sample size (last row). In the first one, the values are all close to 0, because we generated our sample from a Gaussian with mean 0, and the values in the second one are all close to the values in the column names (which refer to the variance of the distribution of the sample). This means that for with a sample size of 2000, our estimates are really close to the \"True\" values (with which we generated the sample). Also, the Skew of a Gaussian distribution should be 0, and it is confirmed in the 3rd DataFrame where the values are close to 0 in the last row (i.e big sample size).\n</p>\n\n<b>2) Same as before but with a Poisson distribution (which has just one parameter lambda instead of 2 like the gaussian)</b>\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# Defining a few variables se we can change their values easiliy without having to change the rest of the code\nn = [5, 20, 100, 2000]\nlambd = [0.5, 1, 3] # In a gaussian we had two parameters, a var specified here and a mean we chose to be 0 \n#everywhere. Here we have one parameter called lambda.\n\n# Initializing empty 2D arrays where we're going to store the results of our simulation\nmean = np.empty([len(n), len(lambd)])\nstd = np.empty([len(n), len(lambd)])\nskewness = np.empty([len(n), len(lambd)])\nkurtos = np.empty([len(n), len(lambd)])\n\n# Conducting the experiments and storing the results in the respective 2D arrays\nfor i, sample_size in enumerate(n):\n    for j, theoritical_lambd in enumerate(lambd):\n        #**********************************************************************\n        sample = np.random.poisson(lam = theoritical_lambd, size = sample_size) # THIS IS WHAT WE CHANGED IN Q2 !\n        #**********************************************************************\n        mean[i,j] = sample.mean()\n        std[i,j] = sample.std()\n        skewness[i,j] = skew(sample)\n        kurtos[i,j] = kurtosis(sample)\n\n# Turning the mean 2D array into a pandas dataframe\nmean = pd.DataFrame(mean, columns = lambd, index = n)\nmean = mean.rename_axis('Sample Size').rename_axis(\"Lambda\", axis=\"columns\")\n\n# Turning the std 2D array into a pandas dataframe\nstd = pd.DataFrame(std, columns = lambd, index = n)\nstd = std.rename_axis('Sample Size').rename_axis(\"Lambda\", axis=\"columns\")\n\n# Turning the skewness 2D array into a pandas dataframe\nskewness = pd.DataFrame(skewness, columns = lambd, index = n)\nskewness = skewness.rename_axis('Sample Size').rename_axis(\"Lambda\", axis=\"columns\")\n\n# Turning the kurtosis 2D array into a pandas dataframe\nkurtos = pd.DataFrame(kurtos, columns = lambd, index = n)\nkurtos = kurtos.rename_axis('Sample Size').rename_axis(\"Lambda\", axis=\"columns\")\n\nprint(\"POISSON DISTRIBUTION\\n\")\nprint('Results for the Mean :')\nmean # This is a dataframe containing the means of the samples generated with different values of std and sample size\nprint('Results for the Standard Deviation :')\nstd # This is a dataframe containing the standard deviations of the samples generated with different values of std \n#and sample size\nprint('Results for the Skewness :')\nskewness # This is a dataframe containing the skews of the samples generated with different values of std and sample \n#size\nprint('Results for the Kurtosis :')\nkurtos # This is a dataframe containing the kurtosis of the samples generated with different values of std and sample \n#size\n\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPOISSON DISTRIBUTION\n\nResults for the Mean :\nResults for the Standard Deviation :\nResults for the Skewness :\nResults for the Kurtosis :\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Lambda</th>\n      <th>0.5</th>\n      <th>1.0</th>\n      <th>3.0</th>\n    </tr>\n    <tr>\n      <th>Sample Size</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>5</th>\n      <td>-0.921875</td>\n      <td>-0.270833</td>\n      <td>-1.750000</td>\n    </tr>\n    <tr>\n      <th>20</th>\n      <td>0.129646</td>\n      <td>0.314879</td>\n      <td>-1.356271</td>\n    </tr>\n    <tr>\n      <th>100</th>\n      <td>1.153720</td>\n      <td>-0.578581</td>\n      <td>-0.599036</td>\n    </tr>\n    <tr>\n      <th>2000</th>\n      <td>1.463024</td>\n      <td>0.901877</td>\n      <td>-0.082689</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<p>\n    Just remember, the lambda parameter that defines the Poisson distribution is also the mean of the distribution. This is confirmed in the first DataFrame where the values (means of samples) are close to the column labels (theoretical lambda which is also equal to theoretical mean), especially in the last row.\n</p>\n\n## Robust Statistics\n\n1) Choose a number of columns with different shapes, for instance, \"e_prev_100k_hi\" is left skewed or some columns where the variation is high or you notice potential outliers. You can make use of a series of boxplots to exploratively analyse the data for outliers\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Listing the columns\ndf_tuber.columns\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nIndex(['country', 'iso2', 'iso3', 'iso_numeric', 'g_whoregion', 'year',\n       'e_pop_num', 'e_prev_100k', 'e_prev_100k_lo', 'e_prev_100k_hi',\n       'e_prev_num', 'e_prev_num_lo', 'e_prev_num_hi', 'e_mort_exc_tbhiv_100k',\n       'e_mort_exc_tbhiv_100k_lo', 'e_mort_exc_tbhiv_100k_hi',\n       'e_mort_exc_tbhiv_num', 'e_mort_exc_tbhiv_num_lo',\n       'e_mort_exc_tbhiv_num_hi', 'source_mort', 'e_inc_100k', 'e_inc_100k_lo',\n       'e_inc_100k_hi', 'e_inc_num', 'e_inc_num_lo', 'e_inc_num_hi',\n       'e_tbhiv_prct', 'e_tbhiv_prct_lo', 'e_tbhiv_prct_hi',\n       'e_inc_tbhiv_100k', 'e_inc_tbhiv_100k_lo', 'e_inc_tbhiv_100k_hi',\n       'e_inc_tbhiv_num', 'e_inc_tbhiv_num_lo', 'e_inc_tbhiv_num_hi',\n       'source_tbhiv', 'c_cdr', 'c_cdr_lo', 'c_cdr_hi'],\n      dtype='object')\n```\n:::\n:::\n\n\n::: {.cell .column-screen-inset execution_count=18}\n``` {.python .cell-code}\n# Alright I already know a few columns with outliers but let's try to find them together exploratively using BoxPlots\ncolname = 'c_cdr' # change the column name by choosing different ones from above (numeric ones)\nplt.figure(figsize=(15,5))\nplt.subplot(1,2,1)\nplt.hist(df_tuber[colname])\nplt.title('Histogram of \"{}\"'.format(colname))\nplt.subplot(1,2,2)\nplt.boxplot(df_tuber[colname]);\nplt.title('Boxplot of \"{}\"'.format(colname));\n```\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_3_1_Data_Processing_and_Summarization_files/figure-html/cell-19-output-1.png){width=1179 height=431}\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# Chosen columns : I picked 3, feel free to change them and experiment\nchosen_colnames = ['e_pop_num', 'e_prev_100k', 'c_cdr']\n```\n:::\n\n\n<b>2) For the chosen columns, estimate both the conventional and the robust descriptive statistics and compare. Observe how these pairs deviate from each other based on the characteristics of the underlying data</b>\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Central Tendency : Mean vs Median (Median is the robust version of the mean, because it takes into account \n#the ordering of the points and not the actual values like the mean does)\ndf_tuber[chosen_colnames].describe().loc[['mean', '50%'], :] # The 50% is the median (50% quantile)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>e_pop_num</th>\n      <th>e_prev_100k</th>\n      <th>c_cdr</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>mean</th>\n      <td>2.899179e+07</td>\n      <td>207.694422</td>\n      <td>67.570706</td>\n    </tr>\n    <tr>\n      <th>50%</th>\n      <td>5.140332e+06</td>\n      <td>93.000000</td>\n      <td>70.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLook at how the values are different between the mean and the median ... LOOOOOOOK ! This is why when you have a skewed (unsymmetrical) distribution it's usually more interesting to use the median as a measure of the central tendency of the data. One important thing to note here, for the two first attributes, the mean is higher than the median, but for the last it's the opposite. This can tell you a thing or two about the shape of your distribution : if the mean is higher than the median, this means that the distribution is skewed to the right (right tail) which pulls the mean higher. And vice-versa.\n\n\nMoral of the story is ... outliers are a pain in the a**. \n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Spread : Standard Deviation vs Inter-Quartile Range vs Median Absolute Deviation (MAD)\nstds = df_tuber[chosen_colnames].std()\niqrs = df_tuber[chosen_colnames].quantile(0.75) - df_tuber[chosen_colnames].quantile(0.25)\nmedianAD = mad(df_tuber[chosen_colnames])\n\noutput = pd.DataFrame(stds, columns = ['std']).T\noutput = pd.concat([output, pd.DataFrame(iqrs, columns = ['IQR']).T], ignore_index=False)\noutput = pd.concat([output, pd.DataFrame(medianAD, columns = ['MAD'], index = chosen_colnames).T], ignore_index=False, names = ['std', 'iqr', 'mad'])\noutput\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>e_pop_num</th>\n      <th>e_prev_100k</th>\n      <th>c_cdr</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>std</th>\n      <td>1.177827e+08</td>\n      <td>269.418159</td>\n      <td>25.234773</td>\n    </tr>\n    <tr>\n      <th>IQR</th>\n      <td>1.677193e+07</td>\n      <td>280.500000</td>\n      <td>34.000000</td>\n    </tr>\n    <tr>\n      <th>MAD</th>\n      <td>7.454908e+06</td>\n      <td>120.090780</td>\n      <td>25.204238</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe values here are different as well, maybe more so for the \"e_pop_num\" attribute than the others, but that is just because of the scaling : \"e_pop_num\" takes big values overall compared to the other columns, which you can check with the mean values right above.\n\nFor the first attribute, the standard deviation is higher, and both the IQR and MAD are close to each other. For the second attribute, the inter-quartile range is slightly higher than the standard deviation, but the MAD is far below (less than half) the other two values, and the reason for that is a little bit involved : Basically, the standard deviation measures the spread by computing the squared deviation from the mean while the median absolute deviation evaluates the spread by computing the absolute deviation. This means that when the outliers have much bigger values than the \"normal\" points, the squared difference explodes (figuratively of course ;p) compared to the absolute difference. And this is actually the case for our second distribution (e_prev_100k) where most values are between 50 and 300 while many outliers lay above the 750 mark and go all the way up to 1800 (look at the boxplots below). For the third attribute the values are somewhat close, especially the std and the MAD, that's because if you inspect the boxplot, this column doesn't have many outliers to begin with.\n\nNonetheless, the differences are real, and if we don't want to have to handle outliers, then we should be using robust statistics like the median to describe the central tendency and inter-quartile range or median absolute deviation to measure the spread of our data.\n\n::: {.cell .column-page-inset-right execution_count=22}\n``` {.python .cell-code}\n# Boxplots of the different columns\nplt.figure(figsize=(12,20))\n\nplt.subplot(3,2,1)\nplt.hist(df_tuber[chosen_colnames[0]])\nplt.title('Histogram of \"{}\"'.format(chosen_colnames[0]))\nplt.subplot(3,2,2)\nplt.boxplot(df_tuber[chosen_colnames[0]])\nplt.title('Boxplot of \"{}\"'.format(chosen_colnames[0]))\n\nplt.subplot(3,2,3)\nplt.hist(df_tuber[chosen_colnames[1]])\nplt.title('Histogram of \"{}\"'.format(chosen_colnames[1]))\nplt.subplot(3,2,4)\nplt.boxplot(df_tuber[chosen_colnames[1]])\nplt.title('Boxplot of \"{}\"'.format(chosen_colnames[1]))\n\nplt.subplot(3,2,5)\nplt.hist(df_tuber[chosen_colnames[2]])\nplt.title('Histogram of \"{}\"'.format(chosen_colnames[2]))\nplt.subplot(3,2,6)\nplt.boxplot(df_tuber[chosen_colnames[2]])\nplt.title('Boxplot of \"{}\"'.format(chosen_colnames[2]));\n```\n\n::: {.cell-output .cell-output-display}\n![](IM939_Lab_3_1_Data_Processing_and_Summarization_files/figure-html/cell-23-output-1.png){width=955 height=1540}\n:::\n:::\n\n\n",
    "supporting": [
      "IM939_Lab_3_1_Data_Processing_and_Summarization_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}